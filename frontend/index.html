<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web2Wire: Global Light Control</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        /* Custom Neon Green Color and Glow */
        :root {
            --neon-green: #39FF14;
            --dark-bg: #0d0d0d;
        }

        body {
            background-color: var(--dark-bg);
            color: var(--neon-green);
            font-family: 'Space Mono', monospace;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            /* Create the radar/crosshair background effect */
            background-image: 
                radial-gradient(circle at center, transparent 0, transparent 50%, rgba(57, 255, 20, 0.1) 60%, transparent 100%),
                linear-gradient(to right, rgba(57, 255, 20, 0.1) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(57, 255, 20, 0.1) 1px, transparent 1px);
            background-size: 100% 100%, 50px 50px, 50px 50px;
            background-position: center center;
        }

        .neon-text {
            text-shadow: 0 0 5px var(--neon-green), 0 0 10px var(--neon-green);
        }

        .neon-box {
            box-shadow: 0 0 15px rgba(57, 255, 20, 0.8), 0 0 5px rgba(57, 255, 20, 0.5);
            border: 1px solid var(--neon-green);
        }

        .neon-input {
            background-color: #1a1a1a;
            border: 1px solid var(--neon-green);
            color: var(--neon-green);
            box-shadow: inset 0 0 5px rgba(57, 255, 20, 0.5);
        }

        .neon-btn {
            background-color: var(--neon-green);
            color: #000;
            font-weight: bold;
            text-shadow: none;
            transition: all 0.2s;
        }

        .neon-btn:hover:not(:disabled) {
            box-shadow: 0 0 10px var(--neon-green), 0 0 20px var(--neon-green);
            background-color: #66ff33;
        }
        
        .neon-btn:disabled {
            background-color: #333;
            color: #888;
            cursor: not-allowed;
            box-shadow: none;
        }
        
        /* Removed select.neon-input custom styling as we are using a custom component */

        /* Specific style for the small refresh button */
        #refresh-btn {
            background-color: #1a1a1a;
            color: var(--neon-green);
            border: 1px solid var(--neon-green);
            padding: 4px 8px;
            font-size: 0.75rem;
            line-height: 1;
            margin-left: 10px;
            transition: background-color 0.2s;
        }

        #refresh-btn:hover:not(:disabled) {
            background-color: rgba(57, 255, 20, 0.2);
        }

        /* Custom Dropdown List Item Styling */
        .country-option {
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            transition: background-color 0.1s;
        }

        .country-option:hover {
            background-color: rgba(57, 255, 20, 0.2);
        }
    </style>
</head>
<body class="p-4">

    <div id="app-container" class="max-w-xl w-full p-6 rounded-lg neon-box bg-gray-900/90 backdrop-blur-sm">
        
        <h1 class="text-3xl font-bold mb-2 neon-text text-center">
            <span class="inline-block animate-pulse">‚ö°</span> Web2Wire: Global Light Control
        </h1>
        <p class="text-center text-sm mb-6 text-gray-400">
            Securely bridge the web to the physical wire. Send a pulse!
        </p>

        <div class="mb-6 p-3 rounded-md border-b-2 border-dashed border-green-500/50">
            <span class="uppercase text-xs tracking-widest text-gray-300">System Status:</span>
            
            <div class="flex justify-between items-center mt-1 mb-2">
                <span class="text-lg neon-text">Queue Size:</span>
                <span class="flex items-center">
                    <span id="queue-status" class="text-xl font-mono neon-text animate-pulse">Awaiting Signal...</span>
                    <button id="refresh-btn" type="button" class="rounded neon-box ml-4">
                        <svg class="w-4 h-4 inline" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m9.67 6.588l-1.415-1.415a2 2 0 112.828-2.828l1.415 1.415M20 20v-5h-.582"></path></svg>
                    </button>
                </span>
            </div>

            <div class="flex justify-between items-center text-sm border-t border-dashed border-green-500/20 pt-2">
                <span class="text-sm text-gray-400">Est. Wait Time:</span>
                <span id="wait-time-display" class="font-mono text-yellow-400">Loading...</span>
            </div>

        </div>

        <form id="control-form" class="space-y-4">
            <div>
                <label for="user-name" class="block text-sm font-medium mb-1 neon-text">USER ID (Name):</label>
                <input type="text" id="user-name" required placeholder="Enter your callsign (max 20 chars)" maxlength="20"
                        class="w-full p-3 rounded neon-input focus:outline-none focus:ring-2 focus:ring-green-500">
            </div>

            <!-- --- FIX: Custom Dropdown for Country Selection --- -->
            <div class="relative">
                <label for="country-input" class="block text-sm font-medium mb-1 neon-text">ORIGIN (Country):</label>
                <input type="text" id="country-input" required placeholder="Select or type your source nation" readonly 
                        class="w-full p-3 rounded neon-input focus:outline-none focus:ring-2 focus:ring-green-500 cursor-pointer">
                
                <!-- Hidden input to store the final selected value (optional, but good practice) -->
                <input type="hidden" id="user-country" required>

                <!-- Dropdown List Container -->
                <div id="country-dropdown" class="absolute z-10 w-full mt-1 bg-gray-900/95 neon-box rounded-md shadow-lg 
                                                 max-h-64 overflow-y-auto hidden">
                    <!-- Options will be populated here by JavaScript -->
                </div>
            </div>
            <!-- --- END FIX --- -->

            <button type="submit" id="submit-btn" class="w-full p-3 rounded neon-btn mt-4 shadow-lg shadow-green-500/30">
                INITIATE PULSE SEQUENCE <span class="ml-2">‚Üí</span>
            </button>
        </form>

        <div id="message" class="mt-6 p-4 rounded-md font-mono text-left whitespace-pre-wrap">
            <span class="text-sm">STATUS_LOG: Waiting for user input...</span>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const API_BASE_URL = 'https://api.circuitsmiles.dev'; // Target the Control API
        const QUEUE_STATUS_URL = 'https://queue.circuitsmiles.dev/api/queue/status'; // Target the Queue API
        const TIME_PER_REQUEST_SEC = 5; // Assumption: each item takes 5 seconds to process

        // --- DOM Elements ---
        const form = document.getElementById('control-form');
        const submitBtn = document.getElementById('submit-btn');
        const messageDiv = document.getElementById('message');
        const queueStatusSpan = document.getElementById('queue-status');
        const refreshBtn = document.getElementById('refresh-btn');
        const waitTimeDisplay = document.getElementById('wait-time-display'); 
        const countryInput = document.getElementById('country-input'); // Custom input field
        const userCountryHidden = document.getElementById('user-country'); // Hidden field for form value
        const countryDropdown = document.getElementById('country-dropdown'); // Custom dropdown list
        const neonGreenColor = 'var(--neon-green)';

        // --- GLOBAL STATE for Ticking Timer ---
        let countdownInterval = null;
        let secondsRemaining = 0; 
        
        // --- COUNTRY CODE MAPPING ---
        const COUNTRY_CODES = {
            "Argentina": "AR", "Australia": "AU", "Austria": "AT", "Belgium": "BE", "Brazil": "BR", "Canada": "CA", 
            "Chile": "CL", "China": "CN", "Colombia": "CO", "Denmark": "DK", "Egypt": "EG", "Finland": "FI", 
            "France": "FR", "Germany": "DE", "Greece": "GR", "India": "IN", "Indonesia": "ID", "Ireland": "IE", 
            "Italy": "IT", "Japan": "JP", "Kenya": "KE", "Mexico": "MX", "Netherlands": "NL", "New Zealand": "NZ", 
            "Norway": "NO", "Poland": "PL", "Portugal": "PT", "South Africa": "ZA", "South Korea": "KR", 
            "Spain": "ES", "Sweden": "SE", "Switzerland": "CH", "Turkey": "TR", "United Kingdom": "GB", 
            "United States": "US", "Other": "ZZ"
        };
        const COUNTRY_NAMES = Object.keys(COUNTRY_CODES);


        // --- UTILITY: Format wait time in seconds to minutes and seconds ---
        function formatWaitTime(seconds) {
            seconds = Math.max(0, seconds); 
            if (seconds <= 0) return "Less than 5 seconds";
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            
            let parts = [];
            if (minutes > 0) parts.push(`${minutes} min`);
            if (remainingSeconds > 0) parts.push(`${remainingSeconds} sec`);
            
            return parts.join(' ');
        }

        // --- UTILITY: Update Message Box ---
        function logMessage(text, type = 'info') {
            let bgColor = 'bg-gray-800';
            let textColor = neonGreenColor;
            let icon = '>';

            if (type === 'success') {
                bgColor = 'bg-green-900/30';
                textColor = neonGreenColor;
                icon = '‚úÖ';
            } else if (type === 'error') {
                bgColor = 'bg-red-900/30';
                textColor = '#FF6347'; 
                icon = '‚ùå';
            } else if (type === 'limit') {
                bgColor = 'bg-yellow-900/30';
                textColor = '#FFFF00'; 
                icon = '‚ö†Ô∏è';
            } else if (type === 'refresh') {
                bgColor = 'bg-blue-900/30';
                textColor = '#00BFFF';
                icon = 'üîÑ';
            }

            messageDiv.style.backgroundColor = bgColor;
            messageDiv.style.color = textColor;
            messageDiv.innerHTML = `${icon} <span class="text-xs">${new Date().toLocaleTimeString()}</span>\n${text}`;
        }
        
        // --- COUNTDOWN LOGIC ---
        function startWaitTimeCountdown(initialQueueSize) {
            if (countdownInterval) {
                clearInterval(countdownInterval);
            }

            secondsRemaining = initialQueueSize * TIME_PER_REQUEST_SEC;

            if (secondsRemaining <= 0) {
                waitTimeDisplay.textContent = "Immediate access available";
                return;
            }

            const initialFormattedTime = formatWaitTime(secondsRemaining);
            waitTimeDisplay.textContent = `${initialFormattedTime} (${TIME_PER_REQUEST_SEC}s/req)`;

            countdownInterval = setInterval(() => {
                secondsRemaining = Math.max(0, secondsRemaining - 1);
                
                const currentFormattedWaitTime = formatWaitTime(secondsRemaining);
                waitTimeDisplay.textContent = `${currentFormattedWaitTime} (${TIME_PER_REQUEST_SEC}s/req)`;
                
                if (secondsRemaining <= 0) {
                    clearInterval(countdownInterval);
                    countdownInterval = null;
                    waitTimeDisplay.textContent = "Processing now...";
                    // Wait a moment and fetch the new status to reset the size
                    setTimeout(() => fetchQueueStatus(false), 2000); 
                }
            }, 1000); 
        }

        // --- CUSTOM DROPDOWN LOGIC ---

        // Function to select a country from the list
        function selectCountry(countryName) {
            countryInput.value = countryName;
            userCountryHidden.value = countryName;
            countryDropdown.classList.add('hidden');
            // Re-enable readonly after selection
            countryInput.readOnly = true; 
        }

        // Function to render the list of countries (filtered by search term)
        function renderCountryOptions(filter = '') {
            countryDropdown.innerHTML = ''; // Clear previous options
            const lowerFilter = filter.toLowerCase();

            const filteredCountries = COUNTRY_NAMES.filter(name => 
                name.toLowerCase().includes(lowerFilter)
            );

            if (filteredCountries.length === 0) {
                const noResult = document.createElement('div');
                noResult.className = 'country-option text-gray-500 cursor-default';
                noResult.textContent = `No results for "${filter}"`;
                countryDropdown.appendChild(noResult);
                return;
            }

            filteredCountries.forEach(countryName => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'country-option hover:text-black'; // hover:text-black makes the hover look nice on neon-btn background
                optionDiv.textContent = countryName;
                optionDiv.addEventListener('mousedown', (e) => {
                    // Use mousedown instead of click to prevent the input field's blur event
                    // from hiding the dropdown before the click event registers.
                    e.preventDefault(); 
                    selectCountry(countryName);
                });
                countryDropdown.appendChild(optionDiv);
            });
        }

        // Event listener to show/hide the dropdown
        countryInput.addEventListener('click', () => {
             // If clicked, make input editable for filtering and show the list
            countryInput.readOnly = false;
            countryInput.focus();
            countryDropdown.classList.remove('hidden');
            renderCountryOptions(countryInput.value); // Re-render with current value
        });

        // Event listener for filtering as user types
        countryInput.addEventListener('input', () => {
            userCountryHidden.value = ''; // Clear hidden value while typing
            renderCountryOptions(countryInput.value);
            countryDropdown.classList.remove('hidden'); // Ensure it stays visible
        });
        
        // Hide dropdown when focus is lost (except for the list itself)
        countryInput.addEventListener('blur', () => {
            // Delay to allow the mousedown event on an option to register
            setTimeout(() => {
                if (!countryDropdown.contains(document.activeElement)) {
                    countryDropdown.classList.add('hidden');
                    // If blur happens and no country was selected, reset the input to the last known valid value or empty
                    if (!userCountryHidden.value && countryInput.value) {
                         // Check if the typed value matches a country name
                         if (COUNTRY_NAMES.includes(countryInput.value)) {
                            userCountryHidden.value = countryInput.value;
                         } else {
                            countryInput.value = ''; // Clear if it's not a valid country
                         }
                    } else if (userCountryHidden.value) {
                         // Restore the last selected valid country name to the visible input
                         countryInput.value = userCountryHidden.value;
                    }
                    countryInput.readOnly = true; // Make it read-only again after interaction
                }
            }, 100);
        });

        // --- 1. HANDLE FORM SUBMISSION ---
        form.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            // --- GET VALUE FROM THE HIDDEN INPUT ---
            const countryName = userCountryHidden.value; 

            if (!countryName) {
                logMessage('ERROR: Please select a valid country.', 'error');
                countryInput.focus();
                countryDropdown.classList.remove('hidden');
                return;
            }

            const name = document.getElementById('user-name').value;
            
            // Map the full country name to its 2-letter code (the 'flag' value)
            const flagCode = COUNTRY_CODES[countryName] || 'ZZ'; 

            submitBtn.disabled = true;
            logMessage('ATTEMPTING HANDSHAKE... Validating payload.', 'info');

            const payload = { 
                name, 
                country: countryName, 
                flag: flagCode 
            }; 

            try {
                // Simplified fetch retry logic (exponential backoff not fully implemented here due to complexity constraints)
                const response = await fetch(`${API_BASE_URL}/api/request/new`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();

                if (response.ok) {
                    const queuePosition = result.queue_size; 
                    const waitTimeSeconds = queuePosition * TIME_PER_REQUEST_SEC;
                    const formattedWaitTime = formatWaitTime(waitTimeSeconds);
                    
                    startWaitTimeCountdown(queuePosition);

                    logMessage(`PULSE ACCEPTED: ${result.message}
> YOUR POSITION: ${queuePosition} in queue
> ORIGIN CODE: ${flagCode}
> EST. WAIT TIME: ${formattedWaitTime} (${TIME_PER_REQUEST_SEC}s/request)`, 'success');

                } else if (response.status === 429) {
                    logMessage(`[ERROR 429] RATE LIMIT EXCEEDED. Access restricted.\n> ${result.message}`, 'limit');
                } else {
                    logMessage(`[ERROR ${response.status}] FAILED: ${result.message}`, 'error');
                }

            } catch (error) {
                logMessage(`[ERROR NET] CRITICAL FAILURE: Could not establish connection to Control API.`, 'error');
                console.error("Network Error:", error);
            } finally {
                submitBtn.disabled = false;
                fetchQueueStatus(false); 
            }
        });

        // --- 2. FETCH QUEUE STATUS ---
        async function fetchQueueStatus(log = true) {
            
            if (log) {
                 logMessage('MANUAL REFRESH: Fetching updated queue status.', 'refresh');
            }
            
            refreshBtn.disabled = true;
            
            try {
                const response = await fetch(QUEUE_STATUS_URL);
                if (response.ok) {
                    const result = await response.json();
                    
                    const queuePosition = result.queue_size;
                    
                    startWaitTimeCountdown(queuePosition);

                    queueStatusSpan.textContent = queuePosition;
                    queueStatusSpan.classList.remove('text-red-500', 'text-yellow-500');
                    queueStatusSpan.classList.add('neon-text');
                    
                    if (log) { 
                        const formattedWaitTime = formatWaitTime(queuePosition * TIME_PER_REQUEST_SEC);
                        logMessage(`Queue status updated successfully.
> Current size: ${queuePosition} in queue
> Est. Wait Time: ${formattedWaitTime} (${TIME_PER_REQUEST_SEC}s/request)`, 'info');
                    }

                } else {
                    queueStatusSpan.textContent = 'ERROR (501)';
                    queueStatusSpan.classList.remove('neon-text');
                    queueStatusSpan.classList.add('text-red-500');
                    waitTimeDisplay.textContent = 'Queue API Error';
                }
            } catch (error) {
                queueStatusSpan.textContent = 'OFFLINE';
                queueStatusSpan.classList.remove('neon-text');
                queueStatusSpan.classList.add('text-yellow-500');
                waitTimeDisplay.textContent = 'Offline';
            } finally {
                refreshBtn.disabled = false;
            }
        }
        
        // --- 3. MANUAL REFRESH BUTTON EVENT ---
        refreshBtn.addEventListener('click', () => fetchQueueStatus(true));


        // --- 4. INITIALIZE & POLLING ---
        document.addEventListener('DOMContentLoaded', () => {
            // Initial render of all country options
            renderCountryOptions();

            // Initial fetch on load (don't log it as a 'refresh')
            fetchQueueStatus(false); 
            
            // Poll the queue status every 5 seconds (5000ms)
            setInterval(() => fetchQueueStatus(false), 5000); 
            
            logMessage('SYSTEM BOOT: Waiting for user command.', 'info');
        });
    </script>
</body>
</html>